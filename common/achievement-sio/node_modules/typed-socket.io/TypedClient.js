"use strict";
/**
 * This file is for client-side use.
 */
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
var io = require("socket.io-client");
function getKeys(obj) {
    var keys = [];
    while (obj && obj !== Object.prototype) {
        var properties = Object.getOwnPropertyNames(obj);
        for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
            var prop = properties_1[_i];
            if (keys.indexOf(prop) === -1)
                keys.push(prop);
        }
        obj = Object.getPrototypeOf(obj);
    }
    return keys;
}
/**
 * a class that listens to all the events we declare a method for
 *
 * usage: class MyClass extends TypedClient<S> implements ITypedClient<S>
 */
var TypedClient = /** @class */ (function () {
    function TypedClient(connectPath, config) {
        if (config === void 0) { config = {
            forceWebsockets: false,
        }; }
        var opts = __assign({ autoConnect: false }, config.socketIoOpts);
        if (config.forceWebsockets)
            Object.assign(opts, { transports: ["websocket"], upgrade: false });
        this.socket = io(connectPath, opts);
        util_1.promisifySocket(this.socket);
        if (!this.socket.connected)
            this.socket.connect();
        util_1.autoReconnect(this.socket);
        var messages = getKeys(Object.getPrototypeOf(this));
        for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
            var msg = messages_1[_i];
            if (msg === "constructor" || msg === "destructor")
                continue;
            var fn = this[msg];
            if (typeof fn !== "function")
                throw Error("invalid listener for message " + msg);
            this.socket.on(msg, fn.bind(this));
        }
    }
    TypedClient.prototype.destructor = function () {
        this.socket.removeAllListeners();
        this.socket.disconnect();
    };
    TypedClient.prototype.connect = function () { };
    TypedClient.prototype.connect_error = function (err) {
        console.log("socket connect error", err);
    };
    TypedClient.prototype.error = function (msg) {
        console.error("socket error", msg);
    };
    TypedClient.prototype.disconnect = function (reason) {
        console.log("disconnected, reason:", reason);
    };
    return TypedClient;
}());
exports.TypedClient = TypedClient;
//# sourceMappingURL=TypedClient.js.map