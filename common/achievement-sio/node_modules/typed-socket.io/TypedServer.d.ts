/**
 * typed socket.io server (runtime component)
 */
import * as t from "io-ts";
import * as ts from "./typedSocket";
import { ServerDefinition } from "./typedSocket";
/** use this for calls with no arguments */
export declare const empty: t.UnionType<(t.NullType | t.UndefinedType)[], null | undefined, null | undefined, t.mixed>;
export declare type empty = undefined | null;
/** things that you probably don't need to directly use */
export declare namespace internal {
    interface RuntimeClientRPCStructure {
        [name: string]: {
            request: t.Type<any>;
            response: t.Type<any>;
        };
    }
    interface RuntimeClientMessagesStructure {
        [name: string]: t.Type<any>;
    }
    interface RuntimeServerMessagesStructure {
        [name: string]: t.Type<any>;
    }
    type ClientMessagesHandler<S extends ts.NamespaceSchema> = {
        [k in keyof S["ClientMessages"]]: (message: S["ClientMessages"][k]) => void;
    };
    type ClientRPCsHandler<S extends ts.NamespaceSchema> = {
        [k in keyof S["ClientRPCs"]]: (message: S["ClientRPCs"][k]["request"]) => Promise<S["ClientRPCs"][k]["response"]>;
    };
    type RuntimeNamespaceSchema = {
        ServerMessages: RuntimeServerMessagesStructure;
        ClientMessages: RuntimeClientMessagesStructure;
        ClientRPCs: RuntimeClientRPCStructure;
    };
}
/**
 * a wrapper around all the info needed to create a typed Server and
 * ClientSocketHandler, so we only need to pass one generic parameter to those classes
 */
export declare type NeededInfo<S extends ServerDefinition = ServerDefinition, MyNamespaceSchema extends ts.FullNamespaceSchema = ts.FullNamespaceSchema> = {
    ServerDefinition: S;
    NamespaceSchema: MyNamespaceSchema;
    RuntimeSchema: FromCompiletime<MyNamespaceSchema>;
};
export declare type NeededInfoFor<S extends ServerDefinition, K extends ts.NamespaceNames<S>> = NeededInfo<S, ts.Namespace<S, K>>;
export declare type ToCompiletime<S extends internal.RuntimeNamespaceSchema> = {
    ServerMessages: {
        [k in keyof S["ServerMessages"]]: t.TypeOf<S["ServerMessages"][k]>;
    };
    ClientMessages: {
        [k in keyof S["ClientMessages"]]: t.TypeOf<S["ClientMessages"][k]>;
    };
    ClientRPCs: {
        [k in keyof S["ClientRPCs"]]: {
            request: t.TypeOf<S["ClientRPCs"][k]["request"]>;
            response: t.TypeOf<S["ClientRPCs"][k]["response"]>;
            error: t.mixed;
        };
    };
};
export declare type FromCompiletime<S extends ts.NamespaceSchema> = {
    ServerMessages: {
        [k in keyof S["ServerMessages"]]: t.Type<S["ServerMessages"][k]>;
    };
    ClientMessages: {
        [k in keyof S["ClientMessages"]]: t.Type<S["ClientMessages"][k]>;
    };
    ClientRPCs: {
        [k in keyof S["ClientRPCs"]]: {
            request: t.Type<S["ClientRPCs"][k]["request"]>;
            response: t.Type<S["ClientRPCs"][k]["response"]>;
        };
    };
};
export declare type ToRuntime<S extends ts.NamespaceSchema> = FromCompiletime<S>;
export declare type IClientSocketHandler<N extends NeededInfo> = {
    socket: ts.ServerSideClientSocketNS<N["ServerDefinition"], N["NamespaceSchema"]>;
} & internal.ClientMessagesHandler<N["NamespaceSchema"]> & internal.ClientRPCsHandler<N["NamespaceSchema"]>;
export declare type IPartialClientSocketHandler<N extends NeededInfo> = {
    socket: ts.ServerSideClientSocketNS<N["ServerDefinition"], N["NamespaceSchema"]>;
} & Partial<IClientSocketHandler<N>>;
/**
 * Usage: MyClass extends ClientSocketHandler<X> implements IClientSocketHandler<X> {...}
 */
export declare class ClientSocketHandler<N extends NeededInfo> {
    readonly socket: ts.ServerSideClientSocketNS<N["ServerDefinition"], N["NamespaceSchema"]>;
    _types: {
        [k in keyof N["NamespaceSchema"]["ClientRPCs"]]: N["NamespaceSchema"]["ClientRPCs"][k];
    };
    constructor(socket: ts.ServerSideClientSocketNS<N["ServerDefinition"], N["NamespaceSchema"]>);
}
/**
 * Get the type of the request for a specific client RPC.
 *
 * Example usage:
 *
 * class ChatClient extends ClientSocketHandler<ChatServerInfo>
 *   implements IClientSocketHandler<ChatServerInfo> {
 *   async postMessage(
 *       message: Req<this, "postMessage">,
 *   ): Res<this, "postMessage"> {
 *       ...
 *   }
 * }
 *
 * Sadly somewhat broken due to https://github.com/Microsoft/TypeScript/issues/10727
 */
export declare type Req<C extends ClientSocketHandler<any>, t extends string> = C["_types"][t]["request"];
/**
 * Get the type of the response the server will send for a given client RPC.
 */
export declare type Res<C extends ClientSocketHandler<any>, t extends string> = Promise<C["_types"][t]["response"]>;
export declare const Res: PromiseConstructor;
export interface ServerConfig {
    /** allow the client socket handler to ignore some client messages */
    allowMissingHandlers: boolean;
    /** for RPCs, we usually send type errors back as the first callback argument. When the callback is missing, this logs the error instead */
    logUnsendableErrors: boolean;
}
/**
 * extend this class to create a typed socket.io server
 */
export declare abstract class Server<N extends NeededInfo> {
    readonly schema: N["RuntimeSchema"];
    private readonly __config;
    constructor(schema: N["RuntimeSchema"], config?: Partial<ServerConfig>);
    listen(io: ts.ServerNamespaceNS<N["ServerDefinition"], N["NamespaceSchema"]>): void;
    /**
     * handle an incoming connection. return null to drop the connection or a socket handler object to keep it
     */
    abstract onConnection(clientSocket: ts.ServerSideClientSocketNS<N["ServerDefinition"], N["NamespaceSchema"]>): IPartialClientSocketHandler<N> | null;
    /**
     * called when a client sends a message that has a type error
     */
    onClientMessageTypeError(socket: ts.ServerSideClientSocketNS<N["ServerDefinition"], N["NamespaceSchema"]>, message: string, error: string): void;
    /**
     * return what should be sent as the callback error. override this to customize. By default, the error message will be returned
     *
     * if the callback is missing, onClientMessageTypeError will be called instead
     */
    onClientRPCTypeError(_socket: ts.ServerSideClientSocketNS<N["ServerDefinition"], N["NamespaceSchema"]>, message: string, error: string): any;
    /**
     * override this method to map server-side Promise rejections / throws to a friendly client message
     */
    onClientRPCRejection(_socket: ts.ServerSideClientSocketNS<N["ServerDefinition"], N["NamespaceSchema"]>, _message: string, error: any): any;
    private safeHandleClientMessage<K>(handler, message, args, schema);
    private safeHandleClientRPC(handler, message, args, schema);
}
