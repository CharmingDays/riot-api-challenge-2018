"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * promisify the emit function for RPC calls
 */
function promisifySocket(socket, options) {
    socket.emitAsync = function (type) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return new Promise(function (resolve, reject) {
            (_a = socket).emit.apply(_a, [type].concat(args, [function (err, res) {
                    if (err)
                        reject(err);
                    else
                        resolve(res);
                }]));
            var _a;
        });
    };
    socket.onAsync = function (event, callback) {
        this.on(event, function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (args.length === 0 ||
                typeof args[args.length - 1] !== "function") {
                console.error("invalid callback: " + socket.id + " called", event, "with args", args);
            }
            else {
                var clientCallback_1 = args[args.length - 1];
                callback.apply(void 0, args.slice(0, args.length - 1)).then(function (result) { return clientCallback_1(null, result); })
                    .catch(function (e) {
                    return clientCallback_1(options && options.mapErrors
                        ? options.mapErrors(e)
                        : e);
                });
            }
        });
    };
}
exports.promisifySocket = promisifySocket;
/**
 * automatically reconnect a socket when the backend disconnects
 */
function autoReconnect(socket, minDelay_ms, maxDelay_ms) {
    if (minDelay_ms === void 0) { minDelay_ms = 2000; }
    if (maxDelay_ms === void 0) { maxDelay_ms = 5000; }
    socket.on("disconnect", function (reason) {
        if (reason !== "io server disconnect") {
            // reason == "transport close" or "io client disconnect".
            // "transport close" means the transport layer is down (and thus all socket.io namespaces disconnected), socketio manager will handle auto reconnect
            // "io client disconnect" means *our backend* disconnected
            return;
        }
        // backend is down, try reconnecting periodically.
        // the disconnect event will be received each time because the distributor will accept the connection and then immediately disconnect it
        var delay = minDelay_ms + Math.random() * (maxDelay_ms - minDelay_ms);
        console.log("disconnected from backend, reconnecting in", Math.round(delay), "ms");
        setTimeout(function () {
            if (!socket.connected)
                socket.connect();
        }, delay);
    });
}
exports.autoReconnect = autoReconnect;
//# sourceMappingURL=util.js.map